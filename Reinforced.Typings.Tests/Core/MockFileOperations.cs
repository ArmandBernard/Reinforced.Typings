using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Reinforced.Typings.Ast.Dependency;
using Reinforced.Typings.ReferencesInspection;
using Reinforced.Typings.Visitors.TypeScript;
using Reinforced.Typings.Visitors.Typings;

namespace Reinforced.Typings.Tests.Core
{
    public class MockFileOperations : IFilesOperations
    {
        public bool DeployCalled { get; private set; }
        public bool TempRegistryCleared { get; private set; }

        public ExportContext Context { get; set; }

        public Dictionary<string, string> ExportedFiles { get; private set; }

        public MockFileOperations()
        {
            ExportedFiles = new Dictionary<string, string>();
        }

        public void DeployTempFiles()
        {
            DeployCalled = true;
        }

        public void ClearTempRegistry()
        {
            TempRegistryCleared = true;
        }

        public void Export(string fileName, ExportedFile file, ReferenceProcessorBase refProcessor = null)
        {
            StringBuilder sb = new StringBuilder();
            using (var sw = new StringWriter(sb))
            {
                ExportCore(sw, file,refProcessor);
            }
            ExportedFiles[fileName] = sb.ToString();
        }

        protected virtual void ExportCore(TextWriter tw, ExportedFile file, ReferenceProcessorBase refProcessor = null)
        {
            var visitor = Context.Global.ExportPureTypings 
                ? new TypingsExportVisitor(tw, Context.Global.TabSymbol, Context.Global.ReorderMembers) 
                : new TypeScriptExportVisitor(tw, Context.Global.TabSymbol, Context.Global.ReorderMembers);
            WriteWarning(tw);

            var references = file.References.References;
            if (refProcessor != null)
            {
                references = refProcessor.FilterReferences(references,file);
                if (references == null) references = new RtReference[0];
            }
            bool hasReferences = false;
            foreach (var rtReference in references)
            {
                visitor.Visit(rtReference);
                hasReferences = true;
            }

            var imports = file.References.Imports;
            if (refProcessor != null)
            {
                imports = refProcessor.FilterImports(imports, file);
                if (imports == null) imports = new RtImport[0];
            }
            bool hasImports = false;
            foreach (var rtImport in imports)
            {
                visitor.Visit(rtImport);
                hasImports = true;
            }
            if (hasReferences || hasImports) tw.WriteLine();
            foreach (var fileNamespace in file.Namespaces)
            {
                visitor.Visit(fileNamespace);
            }
        }

        private void WriteWarning(TextWriter tw)
        {
            if (Context.Global.WriteWarningComment)
            {
                tw.WriteLine("//     This code was generated by a Reinforced.Typings tool. ");
                tw.WriteLine("//     Changes to this file may cause incorrect behavior and will be lost if");
                tw.WriteLine("//     the code is regenerated.");
                tw.WriteLine();
            }
        }
    }
}
